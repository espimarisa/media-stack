services:
  # Docker proxy
  dockerproxy:
    image: lscr.io/linuxserver/socket-proxy:latest
    container_name: dockerproxy
    restart: unless-stopped
    networks: [globalNetwork]
    cap_drop: [all]
    environment:
      - CONTAINERS=1
      - SERVICES=1
      - TASKS=1
      - POST=0
    ports:
      - 127.0.0.1:2375:2375
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro

  caddy:
    image: caddy:alpine
    container_name: caddy
    restart: unless-stopped
    network_mode: host # Docker requires network_mode be set to host in order to access the IPv6 public address
    environment:
      - NEXTCLOUD_PUBLISHED_URL=${HOMEPAGE_VAR_NEXTCLOUD_PUBLISHED_URL}
      - SEARXNG_PUBLISHED_URL=${HOMEPAGE_VAR_SEARXNG_PUBLISHED_URL}
      - JELLYFIN_PUBLISHED_URL=${HOMEPAGE_VAR_JELLYFIN_PUBLISHED_URL}
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - ./caddy/certs:/certs
      - ./caddy/config:/config
      - ./caddy/data:/data
      - ./caddy/sites:/srv

  # Redis
  redis:
    container_name: redis
    image: valkey/valkey:8-alpine
    command: valkey-server --save 30 1 --loglevel warning
    restart: unless-stopped
    cap_drop: [ALL]
    cap_add: [SETGID, SETUID, DAC_OVERRIDE]
    networks: [globalNetwork]
    environment:
      - ALLOW_EMPTY_PASSWORD=yes
    volumes:
      - redis:/data

  # SearxNG
  searxng:
    image: searxng/searxng:latest
    container_name: searxng
    restart: unless-stopped
    cap_drop: [ALL]
    cap_add: [CHOWN, SETGID, SETUID]
    networks: [globalNetwork]
    depends_on: [redis]
    environment:
      - SEARXNG_BASEURL=${SEARXNG_BASEURL}
    ports:
      - ${SEARXNG_PORT}:8080
    volumes:
      - searxng:/etc/searxng

  # NextCloud AIO
  nextcloud-aio-mastercontainer:
    init: true
    image: nextcloud/all-in-one:latest
    container_name: nextcloud-aio-mastercontainer
    restart: unless-stopped
    networks: [globalNetwork]
    environment:
      - APACHE_PORT=11000
      - APACHE_IP_BINDING=127.0.0.1
      - NEXTCLOUD_DATADIR=${NEXTCLOUD_DIRECTORY}
      - NEXTCLOUD_UPLOAD_LIMIT=100G
      - NEXTCLOUD_MAX_TIME=12000
      - NEXTCLOUD_MEMORY_LIMIT=8096M # Memory limit, lower if a problem
      - NEXTCLOUD_ENABLE_DRI_DEVICE=true # Disable if /dev/dri doesn't exist
    volumes:
        - nextcloud_aio_mastercontainer:/mnt/docker-aio-config
        - ${STORAGE_DIRECTORY}/nextcloud:/data
        - /var/run/docker.sock:/var/run/docker.sock:ro
    ports:
        - 8080:8080
        - 8443:8443

  # Cloudflare-ddns
  cloudflare-ddns:
    image: favonia/cloudflare-ddns:latest
    container_name: cloudflare-ddns
    restart: always
    network_mode: host # Docker requires network_mode be set to host in order to access the IPv6 public address
    read_only: true
    cap_drop: [all]
    security_opt: [no-new-privileges:true]
    environment:
      - CF_API_TOKEN=${CF_API_TOKEN}
      - DOMAINS=${CF_DOMAINS}
      - PROXIED=${CF_PROXIED}

  # Homepage
  homepage:
    image: ghcr.io/gethomepage/homepage:latest
    container_name: homepage
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    volumes:
      - ./homepage:/app/config # Homepage config
    ports:
      - ${HOMEPAGE_PORT}:${HOMEPAGE_PORT} # Homepage WebUI port

  # qBittorrent
  qbittorrentvpn:
    image: binhex/arch-qbittorrentvpn:latest
    container_name: qbittorrentvpn
    restart: unless-stopped
    privileged: true # Required for WireGuard
    networks: [downloadNetwork]
    cap_add: [NET_ADMIN]
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1 # Required for WireGuard
    environment:
      - VPN_ENABLED=yes
      - VPN_CLIENT=${VPN_CLIENT}
      - VPN_PROV=${VPN_PROV}
      - VPN_USER=${VPN_USER}
      - VPN_PASS=${VPN_PASS}
      - STRICT_PORT_FORWARDING=yes
      - NAME_SERVERS=94.140.14.14,94.140.15.15,2a10:50c0::ad1:ff,2a10:50c0::ad2:ff # AdGuard Public DNS
      - LAN_NETWORK=${LAN_NETWORK}
      - ENABLE_PRIVOXY=yes
      - WEBUI_PORT=${QBITTORRENT_WEBUI_PORT}
      - TZ=${TZ}
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
    volumes:
      - ./qbittorrent-vpn/config:/config
      - ${STORAGE_DIRECTORY}:/storage
      - /lib/modules:/lib/modules
    ports:
      - ${QBITTORRENT_WEBUI_PORT}:${QBITTORRENT_WEBUI_PORT} # qBittorrent WebUI Port
      - ${PRIVOXY_PORT}:${PRIVOXY_PORT} # Privoxy Port

  # Radarr
  radarr:
    image: lscr.io/linuxserver/radarr:latest
    container_name: radarr
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    depends_on: [qbittorrentvpn, prowlarr, flaresolverr]
    environment:
      - TZ=${TZ}
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
    volumes:
      - radarr:/config
      - ${STORAGE_DIRECTORY}:/storage # Point this to your storage/media directory. I use my entire RAID array here
    ports:
      - ${RADARR_PORT}:${RADARR_PORT} # Radarr WebUI port

  # Sonarr
  sonarr:
    image: lscr.io/linuxserver/sonarr:latest
    container_name: sonarr
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    depends_on: [qbittorrentvpn, prowlarr, flaresolverr]
    environment:
      - TZ=${TZ}
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
    volumes:
      - sonarr:/config
      - ${STORAGE_DIRECTORY}:/storage # Point this to your storage/media directory. I use my entire RAID array here
    ports:
      - ${SONARR_PORT}:${SONARR_PORT} # Sonarr WebUI port

  # Readarr
  readarr:
    image: lscr.io/linuxserver/readarr:develop
    container_name: readarr
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    depends_on: [qbittorrentvpn, prowlarr, flaresolverr]
    environment:
      - TZ=${TZ}
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
    volumes:
      - readarr:/config
      - ${STORAGE_DIRECTORY}:/storage # Point this to your storage/media directory. I use my entire RAID array here
    ports:
      - ${READARR_PORT}:${READARR_PORT} # Readarr WebUI port

  # Prowlarr
  prowlarr:
    image: lscr.io/linuxserver/prowlarr:latest
    container_name: prowlarr
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    depends_on: [qbittorrentvpn, flaresolverr]
    environment:
      - TZ=${TZ}
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
    volumes:
      - prowlarr:/config
      - ${STORAGE_DIRECTORY}:/storage # Point this to your storage/media directory. I use my entire RAID array here
    ports:
      - ${PROWLARR_PORT}:${PROWLARR_PORT} # Prowlarr WebUI port

  # Recyclarr
  recyclarr:
    image: ghcr.io/recyclarr/recyclarr:latest
    container_name: recyclarr
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    depends_on: [qbittorrentvpn, radarr, sonarr, prowlarr]
    environment:
      - SONARR_API_KEY=${SONARR_API_KEY}
      - RADARR_API_KEY=${RADARR_API_KEY}
    volumes:
      - ./recyclarr:/config

  # Flaresolverr
  flaresolverr:
    image: ghcr.io/flaresolverr/flaresolverr:latest
    container_name: flaresolverr
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    cap_drop: [all]
    security_opt: [no-new-privileges:true]
    ports:
      - ${FLARESOLVERR_PORT}:${FLARESOLVERR_PORT} # Flaresolverr API Port

  # JellyFin
  jellyfin:
    image: lscr.io/linuxserver/jellyfin:latest
    container_name: jellyfin
    restart: unless-stopped
    runtime: nvidia
    networks: [globalNetwork, downloadNetwork]
    volumes:
      - jellyfin:/config
      - ${MEDIALIBRARY_DIRECTORY}:/data # Point this to your final media library folder
      - /dev/dri:/dev/dri # Remove if /dev/dri doesn't exist
    ports:
      - ${JELLYFIN_HTTP_PORT}:${JELLYFIN_HTTP_PORT} # Jellyfin WebUI port
      - ${JELLYFIN_HTTPS_PORT}:${JELLYFIN_HTTPS_PORT} # Jellyfin HTTPS WebUI port
      - ${JELLYFIN_DLNA_PORT}:${JELLYFIN_DLNA_PORT}/udp # Jellyfin DLNA port
      - ${JELLYFIN_AUTODISCOVERY_PORT}:${JELLYFIN_AUTODISCOVERY_PORT}/udp # Jellyfin Client AutoDiscovery port
    environment:
      - TZ=${TZ}
      - PUID=${PUID}
      - PGID=${PGID}
      - UMASK=${UMASK}
      - DOCKER_MODS=ghcr.io/jumoog/intro-skipper # Allows adding the "skip intro" button to the web UI. Remove if you don't use this plugin
      - NVIDIA_VISIBLE_DEVICES=all # Remove this and the following lines if you do not want NVIDIA support
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]
  # Deemix
  deemix:
    image: registry.gitlab.com/bockiii/deemix-docker:latest
    container_name: deemix
    restart: unless-stopped
    networks: [globalNetwork, downloadNetwork]
    environment:
      - DEEMIX_SINGLE_USER=true # Allows one global user login. Set to false if you wish for all users to provide their own config/ARL
    volumes:
      - deemix:/config
      - ${MEDIALIBRARY_DIRECTORY}/music:/downloads # Point this to where you want to download music to
    ports:
      - ${DEEMIX_PORT}:${DEEMIX_PORT} # Deemix WebUI port

volumes:
  redis:
    external: true
    name: redis-volume
  nextcloud_aio_mastercontainer:
    external: true
    name: nextcloud_aio_mastercontainer
  searxng:
    external: true
    name: searxng-volume
  radarr:
    external: true
    name: radarr-volume
  sonarr:
    external: true
    name: sonarr-volume
  prowlarr:
    external: true
    name: prowlarr-volume
  readarr:
    external: true
    name: readarr-volume
  jellyfin:
    external: true
    name: jellyfin-volume
  deemix:
    external: true
    name: deemix-volume

networks:
  globalNetwork:
    external: true
    name: global-network
  downloadNetwork:
    external: true
    name: download-network
